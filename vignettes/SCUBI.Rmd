---
title: "Single-cell Unbiased Visualization with SCUBI"
output: pdf_document
author:
  - Wenpin Hou, Department of Biostatistics, Johns Hopkins Bloomberg School of Public Health
  - Zhicheng Ji, Department of Biostatistics and Bioinformatics, Duke University School of Medicine
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introductions

Single-cell sequencing measures thousands of features for each cell, which is hard to perceive directly. Dimension reduction techniques such as PCA, t-SNE, and UMAP thus become essential to map the cells with high-dimensional information to a low dimensional space. The reduced dimension representations are then visualized with scatterplots to understand the latent structure of the data, to identify cell subpopulations or developmental trajectories, or to compare across different samples. However, we observe significant biases in such visualization procedure which could lead to problematic interpretations of the data in many real applications. The first bias arises when visualizing the gene expression levels or cell identities. The scatterplot only shows a subset of cells plotted last and the cells plotted earlier are masked and unseen. The second bias arises when comparing the cell type compositions from different types of samples. The scatterplot is biased by the unbalanced total numbers of cells across samples.

To this end, we develop a new visualization method, SCUBI, that tackles these biases. To address the first bias, SCUBI partitions the coordinate space into small non-overlapping squares and visualizes the aggregated information of cells within each square. To address the second bias, SCUBI calculates the proportions of cells falling in non-overlapping squares and visualizes the differences of cell proportions across samples. SCUBI more faithfully reveals the real biological information in the single-cell genomic datasets. 

SCUBI comes with six modes designed for six different scenarios in single-cell data visualization. The first three modes are designed for cell-level visualizations and the last three modes are designed for comparisons across different types of samples.

## Data loading

We demonstrate the utility of SCUBI using a small dataset, which is a subset of a single-cell RNA-seq dataset measuring the gene expression profiles in COVID-19 patients and healthy donors collected from Su et al. Cell, 2020. The dataset is in the format of a Seurat object and we used the following code to extract the first two dimensions of UMAP, the gene expression count matrix, and the severity levels of the samples from which the cells were collected. SCUBI accepts data generated by other software or other pipelines as well, as long as the format follows the basic requirements of SCUBI. Details of the requirements are described in each mode.

```{r}
library(scubi)
library(Seurat)
library(Matrix)
# read in the seurat object
data <- readRDS(paste0(system.file('data',package = 'scubi'),'/scubiexample.rds'))
# the first two dimensions of umap
umap1 <- data$umap@cell.embeddings[,1]
umap2 <- data$umap@cell.embeddings[,2]
str(umap1)
str(umap2)
# the gene expression count matrix
count <- data$RNA@counts
str(count)
# total number of reads for each cell
readcount <- colSums(data)
# sample identity from which cells were colleted
sample <- sub(':.*','',colnames(count))
table(sample)
# sample design matrix
uniquesample <- unique(sample)
design <- data.frame(type=as.numeric(uniquesample=='Se'),row.names = uniquesample)
design
```

## Mode 1: SCUBI for aggregated gene expression
This mode visualizes the expression of a single gene. It can be used to identify groups of cells with high or low expression levels of a marker gene. SCUBI partitions the coordinate space into small non-overlapping squares and visualizes the aggregated information across cells falling in each square.

There are four required inputs: the two dimensions (dim1 and dim2), the gene expression count matrix (count), and the name of the gene to be plotted (gene). Below shows an example plotting the expression of CD3D gene, which is a marker gene for T cells.

```{r}
scubi_expression(dim1 = umap1, dim2 = umap2, count = count, gene = 'CD3D')
```

Optionally, the size of the squares can be controlled by resolution. Resolution is set to be around 10 for UMAP by default. A lower resolution will result in larger squares which aggregates information from more cells but with lower resolution. A small resolution is desired with small number of cells and a large resolution is desired with large number of cells.

Below shows the effect if we decrease resolution to 2, which results in larger squares.

```{r}
scubi_expression(dim1 = umap1, dim2 = umap2, count = count, gene = 'CD3D', resolution=2)
```

SCUBI provides a function to assist in deciding the resolution. For a vector of potential resolution, it calculates the averaged numbers of cells falling in squares. A scatterplot is generated to visualize how this averaged numbers of cells changes with the resolution. A desired resolution is chosen at the elbow point of the plot.

```{r}
resolution(dim1 = umap1, dim2 = umap2)
```

Users can supplier their own palettes using the 'palette' argument.

```{r}
scubi_expression(dim1 = umap1, dim2 = umap2, count = count, gene = 'CD3D', palette = colorRampPalette(c('orange','blue'))(10))
```

By default, SCUBI will automatically generate a plot. For more advanced usage, the plotting process can be turned off and SCUBI will return a data frame used for plotting instead. Users can further customize their own plots using the returned data frame. In this mode, the first four columns define the x- and y-axis boundaries of each square and the last column contains the averaged expression levels.

```{r}
df <- scubi_expression(dim1 = umap1, dim2 = umap2, count = count, gene = 'CD3D', resolution=2, plot = FALSE)
str(df)
```
## Mode 2: SCUBI for averaged continuous measure

This mode visualizes a continuous measure of a cell, such as the total number of reads or the proportion of reads mapped to the mitochondrial genome. It can be used to identify groups of cells with high or low values of the continuous measure. SCUBI partitions the coordinate space into small non-overlapping squares and visualizes the averaged value of the continuous measure across cells falling in each square.

There are three required inputs: the two dimensions (dim1 and dim2) and the continuous value (feature). Below shows an example plotting the total number of reads for each cell.

```{r}
scubi_continuous(dim1 = umap1, dim2 = umap2, feature = readcount)
```

This mode also accepts 'resolution', 'plot', and 'palette' as optional arguments.


## Mode 3: SCUBI for discrete categories

This mode visualizes the distribution of cells with discrete categories, such as the cell types, cell clusters, or the types of samples from which the cells were collected. It can be used to identify the location of a cell cluster, or regions where cells from certain samples are enriched. SCUBI splits the square into multiple pieces, each piece corresponding to one category. The area of the piece reflects the proportion of cells in each category falling in the square. The pieces are colored differently corresponding to different categories.

There are three required inputs: the two dimensions (dim1 and dim2) and the discrete category (feature). Below shows an example plotting the severity levels of the samples from which the cells were collected.

```{r}
scubi_discrete(dim1 = umap1, dim2 = umap2, feature = sample)
```

To address the bias introduced by the unbalanced total number of cells from different categories, this mode also supports normalization of the total number of cells.


```{r}
scubi_discrete(dim1 = umap1, dim2 = umap2, feature = sample, normalize = T)
```

This mode also accepts 'resolution', 'plot', and 'palette' as optional arguments.

## Mode 4: SCUBI for comparing cell type compositions across samples

This mode compares the cell type compositions across different types of samples, such as samples with different levels of disease severities. It can be used to identify the regions where cells from a certain type of samples are enriched. This mode can deal with a continuous covariate, such as to identify enriched cell types with increasing age. Additional sample covariates can be included as well to control for potential confounding effects.

There are four required inputs: the two dimensions (dim1 and dim2), a vector indicating which sample each cell belongs to (sample), and the sample covariates (design). The design can have multiple columns to include multiple covariates, but only the coefficient for the first covariate (first column) will be visualized. Below shows an example plotting the difference of cell type compositions between severe and all other samples. Cell types more enriched in severe are marked as red and cell types deleted in severe are marked as blue.

```{r}
scubi_sample_composition(dim1 = umap1, dim2 = umap2, sample = sample, design = design)
```

By default, the enrichment is smoothed using loess. Smoothing can also be turned off to show the original enrichment.

```{r}
scubi_sample_composition(dim1 = umap1, dim2 = umap2, sample = sample, design = design, smooth=FALSE)
```

Two additional factors supported in this mode are 'clip' and 'scale'. 'clip' replaces very large values for smaller ones and replaces very small values for larger ones, thus reducing the range of data and making the color palette more evenly distributed. 'scale' standardizes the enrichment across all squares to have mean 0 and standard deviation of 1.

This mode also accepts 'resolution', 'plot', and 'palette' as optional arguments.

## Mode 5: SCUBI for comparing gene expression across samples

This mode compares the expression of a single gene across different types of samples. It can be used to identify the regions where gene expression is positively or negatively correlated with the covariate of interest. Similar to mode 4, it can also deal with a continuous variable or include additional covariates.

There are six required inputs: the two dimensions (dim1 and dim2), a gene expression count matrix (count), the name of the gene (gene), a vector indicating which sample each cell belongs to (sample), and the sample covariates (design). Below shows an example plotting the difference of S100A8 gene expression between severe and all other samples. A positive difference (severe higher than others) is marked as red and a negative difference (severe lower than others) is marked as blue.

```{r}
scubi_sample_expression(dim1 = umap1, dim2 = umap2, count = count, gene = 'S100A8', sample = sample, design = design,resolution=3)
```

This mode also accepts 'smooth', 'clip', 'scale', 'resolution', 'plot', and 'palette' as optional arguments.

For this mode and Mode 6 below, SCUBI provides another function to assist in deciding the resolution. For a vector of potential resolution, it calculates the proportion of squares that contain cells from samples at least two different covariate values. A scatterplot is generated to visualize how this proportion changes with the resolution. A desired resolution is chosen at the elbow point of the plot.

```{r}
resolution_sample_expression(dim1 = umap1, dim2 = umap2,sample=sample,design=design)
```

## Mode 6: SCUBI for comparing continuous measure across samples

This mode compares a continuous measure of cells across different types of samples. It can be used to identify the regions where the continuous measure is positively or negatively correlated with the covariate of interest. Similar to mode 4, it can also deal with a continuous variable or include additional covariates.

There are five required inputs: the two dimensions (dim1 and dim2), a vector of continuous measure (feature), a vector indicating which sample each cell belongs to (sample), and the sample covariates (design). Below shows an example plotting the difference of number of read counts between severe and all other samples. A positive difference (severe higher than others) is marked as red and a negative difference (severe lower than others) is marked as blue.

```{r}
scubi_sample_continuous(dim1 = umap1, dim2 = umap2, feature = readcount, sample = sample, design = design,resolution=3)
```

This mode also accepts 'smooth', 'clip', 'scale', 'resolution', 'plot', and 'palette' as optional arguments.


## Session Info
```{r}
sessionInfo()
```
